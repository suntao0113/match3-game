<!DOCTYPE html>
<html>
<head>
  <title>Match-3 Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.min.js"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
    canvas { border: 2px solid #333; }
  </style>
</head>
<body>
<script>
let grid = [];
let cols = 8;
let rows = 8;
let tileSize = 50;
let colors = ['red', 'blue', 'green', 'yellow'];
let score = 0;
let selectedTile = null;
let gameOver = false;
let flashTiles = []; // Store tiles to flash

function setup() {
  try {
    createCanvas(cols * tileSize + 200, rows * tileSize);
    initGrid();
    console.log("Game initialized successfully");
  } catch (e) {
    console.error("Setup error:", e);
  }
}

function draw() {
  background(220);
  drawGrid();
  textSize(20);
  textAlign(LEFT);
  text(`Score: ${score}`, cols * tileSize + 10, 50);
  if (gameOver) {
    textSize(32);
    textAlign(CENTER);
    text('Game Over!', width / 2, height / 2);
  }
}

function mousePressed() {
  if (gameOver) return;
  try {
    let col = floor(mouseX / tileSize);
    let row = floor(mouseY / tileSize);
    if (col >= 0 && col < cols && row >= 0 && row < rows) {
      if (selectedTile) {
        if (isAdjacent(selectedTile, {col, row})) {
          swapTiles(selectedTile, {col, row});
          selectedTile = null;
        } else {
          selectedTile = {col, row};
        }
      } else {
        selectedTile = {col, row};
      }
    }
  } catch (e) {
    console.error("Mouse pressed error:", e);
  }
}

function initGrid() {
  try {
    for (let i = 0; i < cols; i++) {
      grid[i] = [];
      for (let j = 0; j < rows; j++) {
        grid[i][j] = floor(random(colors.length));
      }
    }
    removeInitialMatches();
  } catch (e) {
    console.error("Grid init error:", e);
  }
}

function drawGrid() {
  try {
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        if (grid[i][j] >= 0 && grid[i][j] < colors.length) {
          if (flashTiles.some(t => t.col === i && t.row === j)) {
            fill(255); // Flash with white
          } else {
            fill(colors[grid[i][j]]);
          }
          rect(i * tileSize, j * tileSize, tileSize - 2, tileSize - 2);
        } else {
          fill(150); // Gray for invalid states
          rect(i * tileSize, j * tileSize, tileSize - 2, tileSize - 2);
          console.warn("Invalid grid value at", i, j, ":", grid[i][j]);
        }
      }
    }
    if (selectedTile) {
      stroke(255);
      strokeWeight(4);
      noFill();
      rect(selectedTile.col * tileSize, selectedTile.row * tileSize, tileSize - 2, tileSize - 2);
      strokeWeight(1);
    }
  } catch (e) {
    console.error("Draw grid error:", e);
  }
}

function isAdjacent(tile1, tile2) {
  return (abs(tile1.col - tile2.col) === 1 && tile1.row === tile2.row) ||
         (abs(tile1.row - tile2.row) === 1 && tile1.col === tile2.col);
}

function swapTiles(tile1, tile2) {
  try {
    let temp = grid[tile1.col][tile1.row];
    grid[tile1.col][tile1.row] = grid[tile2.col][tile2.row];
    grid[tile2.col][tile2.row] = temp;
    
    if (!checkMatches()) {
      temp = grid[tile1.col][tile1.row];
      grid[tile1.col][tile1.row] = grid[tile2.col][tile2.row];
      grid[tile2.col][tile2.row] = temp;
    } else {
      handleMatches();
    }
    if (!hasPossibleMoves()) {
      gameOver = true;
      console.log("Game over: No possible moves");
    }
  } catch (e) {
    console.error("Swap tiles error:", e);
  }
}

function checkMatches() {
  let matches = false;
  try {
    for (let j = 0; j < rows; j++) {
      for (let i = 0; i < cols - 2; i++) {
        if (grid[i][j] >= 0 && grid[i][j] === grid[i+1][j] && grid[i][j] === grid[i+2][j]) {
          matches = true;
        }
      }
    }
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows - 2; j++) {
        if (grid[i][j] >= 0 && grid[i][j] === grid[i][j+1] && grid[i][j] === grid[i][j+2]) {
          matches = true;
        }
      }
    }
  } catch (e) {
    console.error("Check matches error:", e);
  }
  return matches;
}

function handleMatches() {
  try {
    let matched = new Set();
    for (let j = 0; j < rows; j++) {
      for (let i = 0; i < cols - 2; i++) {
        if (grid[i][j] >= 0 && grid[i][j] === grid[i+1][j] && grid[i][j] === grid[i+2][j]) {
          matched.add(`${i},${j}`);
          matched.add(`${i+1},${j}`);
          matched.add(`${i+2},${j}`);
        }
      }
    }
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows - 2; j++) {
        if (grid[i][j] >= 0 && grid[i][j] === grid[i][j+1] && grid[i][j] === grid[i][j+2]) {
          matched.add(`${i},${j}`);
          matched.add(`${i},${j+1}`);
          matched.add(`${i},${j+2}`);
        }
      }
    }
    
    if (matched.size > 0) {
      // Convert matched set to array of objects for flashing
      flashTiles = Array.from(matched).map(pos => {
        let [i, j] = pos.split(',').map(Number);
        return {col: i, row: j};
      });
      
      // Flash twice with 1-second intervals, then eliminate
      let flashCount = 0;
      let flashInterval = setInterval(() => {
        flashCount++;
        if (flashCount === 2) {
          clearInterval(flashInterval);
          // Eliminate tiles
          matched.forEach(pos => {
            let [i, j] = pos.split(',').map(Number);
            grid[i][j] = -1;
            score += 10;
          });
          
          // Drop tiles and fill
          for (let i = 0; i < cols; i++) {
            let empty = [];
            for (let j = rows - 1; j >= 0; j--) {
              if (grid[i][j] === -1) {
                empty.push(j);
              } else if (empty.length > 0) {
                grid[i][empty.shift()] = grid[i][j];
                grid[i][j] = -1;
              }
            }
            for (let j of empty) {
              grid[i][j] = floor(random(colors.length));
            }
          }
          
          // Force fill any remaining -1
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              if (grid[i][j] === -1) {
                grid[i][j] = floor(random(colors.length));
                console.warn("Forced fill at", i, j);
              }
            }
          }
          
          // Check for more matches
          flashTiles = [];
          if (checkMatches()) {
            setTimeout(handleMatches, 500); // Slight delay for visual feedback
          }
        }
      }, 1000); // Flash every 1 second
    }
  } catch (e) {
    console.error("Handle matches error:", e);
  }
}

function removeInitialMatches() {
  try {
    let attempts = 0;
    while (checkMatches() && attempts < 100) {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          if (checkMatchesAt(i, j)) {
            grid[i][j] = floor(random(colors.length));
          }
        }
      }
      attempts++;
    }
    if (attempts >= 100) console.warn("Possible infinite loop in removeInitialMatches");
  } catch (e) {
    console.error("Remove initial matches error:", e);
  }
}

function checkMatchesAt(i, j) {
  try {
    if (i <= cols - 3 && grid[i][j] >= 0 && grid[i][j] === grid[i+1][j] && grid[i][j] === grid[i+2][j]) return true;
    if (j <= rows - 3 && grid[i][j] >= 0 && grid[i][j] === grid[i][j+1] && grid[i][j] === grid[i][j+2]) return true;
    return false;
  } catch (e) {
    console.error("Check matches at error:", e);
    return false;
  }
}

function hasPossibleMoves() {
  try {
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        if (i < cols - 1) {
          swap(grid, i, j, i+1, j);
          if (checkMatches()) {
            swap(grid, i, j, i+1, j);
            return true;
          }
          swap(grid, i, j, i+1, j);
        }
        if (j < rows - 1) {
          swap(grid, i, j, i, j+1);
          if (checkMatches()) {
            swap(grid, i, j, i, j+1);
            return true;
          }
          swap(grid, i, j, i, j+1);
        }
      }
    }
    return false;
  } catch (e) {
    console.error("Has possible moves error:", e);
    return false;
  }
}

function swap(grid, i1, j1, i2, j2) {
  try {
    let temp = grid[i1][j1];
    grid[i1][j1] = grid[i2][j2];
    grid[i2][j2] = temp;
  } catch (e) {
    console.error("Swap error:", e);
  }
}

window.addEventListener('error', (e) => {
  if (e.message.includes('p5')) {
    console.error("Failed to load p5.js. Please check the CDN or network connection.");
  }
});
</script>
</body>
</html>
